
import numpy as np

# Package fns.
from epsproc.basicPlotters import molPlot
from epsproc.util.conversion import (conv_ev_atm, conv_ev_nm)

#*************** Summary & display functions

# Print some jobInfo stuff & plot molecular structure
def jobSummary(jobInfo = None, molInfo = None, tolConv = 1e-2):
    """
    Print some jobInfo stuff & plot molecular structure. (Currently very basic.)

    Parameters
    ------------
    jobInfo : dict, default = None
        Dictionary of job data, as generated by :py:function:`epsproc.IO.headerFileParse()` from source ePS output file.

    molInfo : dict, default = None
        Dictionary of molecule data, as generated by :py:func:`epsproc.IO.molInfoParse()` from source ePS output file.

    tolConv : float, default = 1e-2
        Used to check for convergence in ExpOrb outputs, which defines single-center expansion of orbitals.

    Returns
    -------
    Job info : list

    """

    # Pull job summary info
    if jobInfo is not None:
        print('\n*** Job summary data')
        [print(line.strip('#')) for line in jobInfo['comments'][0:4]]
        print(f"\nElectronic structure input: {jobInfo['Convert'][0].split()[1].strip()}")
        print(f"Initial state occ:\t\t {jobInfo['OrbOccInit']}")
        print(f"Final state occ:\t\t {jobInfo['OrbOcc']}")
        print(f"IPot (input vertical IP, eV):\t\t {jobInfo['IPot']}")

        # Additional orb info
        print("\n*** Additional orbital info (SymProd)")
        iList = jobInfo['OrbOccInit'] - jobInfo['OrbOcc']
        print(f"Ionizing orb:\t\t\t {iList}")

        if molInfo is not None:
            # Get orbGrp for event
            iOrbGrp = np.flatnonzero(iList) + 1

            # Find entries in orbTableX
            orbSym = molInfo['orbTable'].where(molInfo['orbTable'].coords['OrbGrp'] == iOrbGrp, drop = True).coords['Sym']
            print(f"Ionizing orb sym:\t\t {np.unique(orbSym)}")

            orbIP = molInfo['orbTable'].where(molInfo['orbTable'].coords['OrbGrp'] == iOrbGrp, drop = True).sel(props = 'E')
            orbIPH = molInfo['orbTable'].where(molInfo['orbTable'].coords['OrbGrp'] == iOrbGrp, drop = True).sel(props = 'EH')
            print(f"Orb energy (eV):\t\t {np.unique(orbIP)}")
            print(f"Orb energy (H):\t\t\t {np.unique(orbIPH)}")

            orbIPnm = conv_ev_nm(np.unique(orbIP))
            print(f"Orb energy (cm^-1):\t\t {1/orbIPnm*1e7}")
            print(f"Threshold wavelength (nm):\t {np.abs(orbIPnm)[0]}")

            # Check ExpOrb outputs...
            ind = (molInfo['orbTable'][:,8].values < 1-tolConv) + (molInfo['orbTable'][:,8].values > 1+tolConv)
            if ind.any():
                print(f"\n*** Warning: some orbital convergences outside single-center expansion convergence tolerance ({tolConv}):")
                print(molInfo['orbTable'][ind, [0, 8]].values)



    # Display structure
    if molInfo is not None:
        print('\n*** Molecular structure\n')
        molPlot(molInfo)

    return jobInfo

# Print (LM) and symmetry sets with Pandas tables
def lmSymSummary(data):
    """Display summary info data tables.

    Works nicely in a notebook cell, with Pandas formatted table... but not from function?

    For a more sophisticated Pandas conversion, see :py:func:`epsproc.util.conversion.multiDimXrToPD`

    """

    print('\n*** Index summary\n')

    test = data.Sym.to_pandas()
    print('Symmetry sets')
    print(test.unstack())

    test = data.LM.to_pandas()
    print('\n(L,M) sets')
    print(test.unstack().T)
